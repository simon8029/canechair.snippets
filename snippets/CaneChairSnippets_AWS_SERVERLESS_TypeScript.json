{
	"ReactJS_AWS_TS_Index.tsx": {
		"prefix": "ccReactJS_AWS_TS_index.tsx",
		"body": [
			"import './index.css';",
			"reportWebVitals();",
			""
		],
		"description": "Create index.tsx file"
	},
	"AWS_SERVERLESS_CONSTANTS_TS": {
		"prefix": "ccAws_Serverless_Constants_Ts",
		"body": [
			"export const CONSTANT = {",
			"  TABLE_ID: '${1:__MICROSERVICE_NAME__}Table',",
			"  TABLE_NAME: 'aws-microservices-${1:__MICROSERVICE_NAME__}',",
			"  TABLE_PK: 'userName',",
			"",
			"  LAMBDA_ID: '${1:__MICROSERVICE_NAME__}Lambda',",
			"  LAMBDA_HANDLER: '${1:__MICROSERVICE_NAME__}LambdaHandler.ts',",
			"",
			"  APIGATEWAY_ID: '${1:__MICROSERVICE_NAME__}ApiGateway',",
			"  APIGATEWAY_NAME: 'aws-microservices-${1:__MICROSERVICE_NAME__}',",
			"  APIGATEWAY_ROOT_RESOURCE: '${1:__MICROSERVICE_NAME__}',",
			"  APIGATEWAY_SINGLE_RESOURCE: '{id}',",
			"}"
		],
		"description": "Create aws serverless constants.ts file"
	},
	"AWS_SERVERLESS_MICROSERVICE_TS": {
		"prefix": "ccAws_Serverless_microService_Ts",
		"body": [
			"import { RemovalPolicy } from 'aws-cdk-lib';",
			"import { LambdaRestApi } from 'aws-cdk-lib/aws-apigateway';",
			"import { AttributeType, BillingMode, ITable, Table } from 'aws-cdk-lib/aws-dynamodb';",
			"import { IFunction, Runtime } from 'aws-cdk-lib/aws-lambda';",
			"import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';",
			"import { Construct } from 'constructs';",
			"",
			"import { CONSTANT } from './constants';",
			"",
			"import path = require('path');",
			"export const create${1:__MICROSERVICE_NAME__}Table = (scope: Construct) => {",
			"  return new Table(scope, CONSTANT.TABLE_ID, {",
			"    partitionKey: { name: CONSTANT.TABLE_PK, type: AttributeType.STRING },",
			"    tableName: CONSTANT.TABLE_NAME,",
			"    removalPolicy: RemovalPolicy.DESTROY,",
			"    billingMode: BillingMode.PAY_PER_REQUEST,",
			"  });",
			"}",
			"",
			"export const create${1:__MICROSERVICE_NAME__}Lambda = (scope: Construct, table: ITable) => {",
			"  const lambdaFunction = new NodejsFunction(scope, CONSTANT.LAMBDA_ID, {",
			"    entry: path.join(__dirname, CONSTANT.LAMBDA_HANDLER),",
			"    runtime: Runtime.NODEJS_18_X,",
			"    environment: {",
			"      PRIMARY_KEY: CONSTANT.TABLE_PK,",
			"      TABLE_NAME: CONSTANT.TABLE_NAME",
			"    },",
			"    bundling: {",
			"      externalModules: ['aws-sdk'],",
			"    },",
			"  });",
			"",
			"  table.grantReadWriteData(lambdaFunction);",
			"  return lambdaFunction;",
			"}",
			"",
			"export const create${1:__MICROSERVICE_NAME__}ApiGateway = (scope: Construct, lambdaFunction: IFunction) => {",
			"  const apiGateway = new LambdaRestApi(scope, CONSTANT.APIGATEWAY_ID, {",
			"    restApiName: CONSTANT.APIGATEWAY_NAME,",
			"    handler: lambdaFunction,",
			"    proxy: false,",
			"  });",
			"",
			"  const rootResource = apiGateway.root.addResource(CONSTANT.APIGATEWAY_ROOT_RESOURCE);",
			"  rootResource.addMethod('GET');",
			"  rootResource.addMethod('POST');",
			"",
			"  const singleResource = rootResource.addResource(CONSTANT.APIGATEWAY_SINGLE_RESOURCE);",
			"  singleResource.addMethod('GET');",
			"  singleResource.addMethod('PUT');",
			"  singleResource.addMethod('DELETE');",
			"}"
		],
		"description": "Create aws serverless microservice.ts file"
	},
	"AWS_SERVERLESS_LAMBDA_HANDLER_TS": {
		"prefix": "ccAws_Serverless_Lambda_Handler_Ts",
		"body": [
			"import { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";",
			"import { ddbClient } from '../../../utils/ddbClient';",
			"import { PutItemCommand, QueryCommand, UpdateItemCommand, DeleteItemCommand, GetItemCommand, ScanCommand, AttributeValue } from '@aws-sdk/client-dynamodb';",
			"import { v4 as uuidv4 } from 'uuid';",
			"import { CONSTANT } from \"./constants\";",
			"",
			"exports.handler = async (event: { httpMethod: any; queryStringParameters: { ${1:__ExpressionAttribute__}: any; }; pathParameters: { id: string; }; body: any; }) => {",
			"  try {",
			"    let body;",
			"",
			"    switch (event.httpMethod) {",
			"      case \"GET\":",
			"        if (event.pathParameters && event.pathParameters.id) {",
			"          body = await getById(event.pathParameters.id);",
			"        } else {",
			"          body = await getAll();",
			"        }",
			"",
			"        if (event.queryStringParameters && event.queryStringParameters.${1:__ExpressionAttribute__}) {",
			"          body = await getByExpressionAttribute(event.queryStringParameters.${1:__ExpressionAttribute__});",
			"        }",
			"        break;",
			"      case \"POST\":",
			"        body = await create(event.body);",
			"        break;",
			"      case \"PUT\":",
			"        body = await update(event);",
			"        break;",
			"      case \"DELETE\":",
			"        body = await remove(event.pathParameters.id);",
			"        break;",
			"",
			"      default:",
			"        throw new Error(`Unsupported method \"${event.httpMethod}\"`);",
			"    }",
			"",
			"    return {",
			"      statusCode: 200,",
			"      headers: {",
			"        'Content-Type': 'application/json',",
			"      },",
			"      body: JSON.stringify(body),",
			"    };",
			"  } catch (error: any) {",
			"    return {",
			"      statusCode: error.statusCode || 500,",
			"      headers: { 'Content-Type': 'text/plain' },",
			"      body: error.message || 'Internal server error.',",
			"      isBase64Encoded: false,",
			"    }",
			"  }",
			"}",
			"",
			"const getAll = async () => {",
			"  try {",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME",
			"    }",
			"",
			"    const { Items } = await ddbClient.send(new ScanCommand(params));",
			"",
			"    return Items ? Items.map(item => unmarshall(item)) : {};",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"}",
			"",
			"const getById = async (id: string) => {",
			"  try {",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME,",
			"      Key: marshall({ id })",
			"    }",
			"",
			"    const { Item } = await ddbClient.send(new GetItemCommand(params));",
			"",
			"    return (Item) ? unmarshall(Item) : null;",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"",
			"}",
			"",
			"const getByExpressionAttribute = async (${1:__ExpressionAttribute__}: string) => {",
			"  try {",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME,",
			"      FilterExpression: \"${1:__ExpressionAttribute__} = :${1:__ExpressionAttribute__}\",",
			"      ExpressionAttributeValues: marshall({ \":${1:__ExpressionAttribute__}\": ${1:__ExpressionAttribute__} })",
			"    }",
			"",
			"    const { Items } = await ddbClient.send(new QueryCommand(params));",
			"",
			"    return Items ? Items.map(item => unmarshall(item)) : {};",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"}",
			"",
			"const create = async (body: string) => {",
			"  try {",
			"    const request = JSON.parse(body);",
			"    request.id = uuidv4();",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME,",
			"      Item: marshall(request || {})",
			"    }",
			"",
			"    const createResult = await ddbClient.send(new PutItemCommand(params));",
			"",
			"    return createResult;",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"}",
			"",
			"const update = async (event: { httpMethod?: any; queryStringParameters?: { ${1:__ExpressionAttribute__}: any; }; pathParameters: any; body: any; }) => {",
			"  try {",
			"    const requestBody = JSON.parse(event.body);",
			"    const objKeys = Object.keys(requestBody);",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME,",
			"      Key: marshall({ id: event.pathParameters.id }),",
			"      UpdateExpression: `set ${objKeys.map((_, index) => `#key${index} = :value${index}`).join(', ')}`,",
			"      ExpressionAttributeNames: objKeys.reduce((acc, key, index) => ({ ...acc, [`#key${index}`]: key }), {}),",
			"      ExpressionAttributeValues: marshall(objKeys.reduce((acc, key, index) => ({ ...acc, [`:value${index}`]: requestBody[key] }), {})),",
			"      ReturnValues: \"ALL_NEW\", // optional (NONE | ALL_OLD | UPDATED_OLD | ALL_NEW | UPDATED_NEW) ",
			"    }",
			"",
			"    const updateResult = await ddbClient.send(new UpdateItemCommand(params));",
			"    return updateResult;",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"}",
			"",
			"",
			"const remove = async (id: string) => {",
			"  try {",
			"    const params = {",
			"      TableName: CONSTANT.TABLE_NAME,",
			"      Key: marshall({ id })",
			"    }",
			"",
			"    const removeResult = await ddbClient.send(new DeleteItemCommand(params));",
			"",
			"    return removeResult;",
			"  } catch (error) {",
			"    throw error;",
			"  }",
			"}"
		],
		"description": "Create aws serverless lambda handler.ts file"
	}
}